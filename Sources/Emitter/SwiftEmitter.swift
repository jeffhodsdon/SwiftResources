// Copyright 2025 Jeff Hodsdon
// SPDX-License-Identifier: Apache-2.0

import Foundation

/// Generates Swift source code for type-safe resource access.
enum SwiftEmitter {
    struct Configuration {
        let moduleName: String
        let accessLevel: String
        let bundleOverride: String? // nil = use BundleFinder
        let registerFonts: Bool
        let forceUnwrap: Bool

        var access: String {
            accessLevel == "public" ? "public " : ""
        }

        var unwrap: String {
            forceUnwrap ? "!" : ""
        }

        var bundleExpression: String {
            guard let override = bundleOverride else {
                return "bundle"
            }

            // Expand shorthand .module to Bundle.module for proper type inference
            if override == ".module" {
                return "Bundle.module"
            }
            return override
        }
    }

    /// Generates Swift source code for the given resources.
    static func emit(
        fonts: [DiscoveredFont],
        images: [DiscoveredImage],
        colors: [DiscoveredColor],
        files: [DiscoveredResource],
        strings: [String: [DiscoveredString]] = [:],
        configuration: Configuration
    ) -> String {
        var output = ""
        let access = configuration.access
        let useBundleFinder = configuration.bundleOverride == nil

        // Header
        output += "// \(configuration.moduleName).swift\n"
        output += "// Generated by SwiftResources â€” do not edit\n\n"

        // Imports
        output += emitImports()

        // BundleFinder (if needed)
        if useBundleFinder {
            output += emitBundleFinder(moduleName: configuration.moduleName)
        }

        // Main enum
        output += "\n\(access)enum \(configuration.moduleName) {\n"

        // Bundle property
        if useBundleFinder {
            output += "    private static let bundle = BundleFinder.resourceBundle\n"
        }

        // Resource type structs
        if !fonts.isEmpty {
            output += emitFontResourceStruct(configuration: configuration)
        }
        if !images.isEmpty {
            output += emitImageResourceStruct(configuration: configuration)
        }
        if !colors.isEmpty {
            output += emitColorResourceStruct(configuration: configuration)
        }
        if !files.isEmpty {
            output += emitFileResourceStruct(configuration: configuration)
        }

        // Resource namespaces
        if !fonts.isEmpty {
            output += emitFontsEnum(fonts: fonts, configuration: configuration)
        }
        if !images.isEmpty {
            output += emitImagesEnum(images: images, configuration: configuration)
        }
        if !colors.isEmpty {
            output += emitColorsEnum(colors: colors, configuration: configuration)
        }
        if !files.isEmpty {
            output += emitFilesEnum(files: files, configuration: configuration)
        }

        // Strings namespace with nested table enums
        if !strings.isEmpty {
            output += emitStringsNamespace(strings: strings, configuration: configuration)
        }

        // Font registration
        if configuration.registerFonts, !fonts.isEmpty {
            output += emitRegisterFonts(fonts: fonts, configuration: configuration)
        }

        output += "}\n"

        return output
    }

    // MARK: - Private Helpers

    private static func emitImports() -> String {
        var output = ""
        output += "import Foundation\n"
        output += "#if canImport(UIKit)\n"
        output += "import UIKit\n"
        output += "#endif\n"
        output += "#if canImport(AppKit)\n"
        output += "import AppKit\n"
        output += "#endif\n"
        output += "#if canImport(SwiftUI)\n"
        output += "import SwiftUI\n"
        output += "#endif\n"
        return output
    }

    private static func emitBundleFinder(moduleName: String) -> String {
        // SPM uses <ModuleName>_<TargetName>.bundle naming
        let bundleName = "\(moduleName)_\(moduleName)"

        var output = "\n"
        output += "private final class BundleFinder {\n"
        output += "    static let resourceBundle: Bundle = {\n"
        output += "        // When built with SPM, Bundle.module is available and preferred\n"
        output += "        #if SWIFT_PACKAGE\n"
        output += "        return Bundle.module\n"
        output += "        #else\n"
        output += "        let bundleName = \"\(bundleName)\"\n"
        output += "        let bundleResourceURL = Bundle(for: BundleFinder.self).resourceURL\n"
        output += "\n"
        output += "        let candidates = [\n"
        output += "            // Bundle should be present here when the package is linked into an App.\n"
        output += "            Bundle.main.resourceURL,\n"
        output += "            // Bundle should be present here when the package is linked into a framework.\n"
        output += "            bundleResourceURL,\n"
        output += "            // For command-line tools.\n"
        output += "            Bundle.main.bundleURL,\n"
        output += "            // Bundle should be present here when running previews from a different package.\n"
        output += "            bundleResourceURL?.deletingLastPathComponent().deletingLastPathComponent().deletingLastPathComponent(),\n"
        output += "            bundleResourceURL?.deletingLastPathComponent().deletingLastPathComponent(),\n"
        output += "            // Other package or embedding scenarios.\n"
        output += "            bundleResourceURL?.deletingLastPathComponent(),\n"
        output += "        ]\n"
        output += "\n"
        output += "        for candidate in candidates {\n"
        output += "            let bundlePath = candidate?.appendingPathComponent(bundleName + \".bundle\")\n"
        output += "            if let bundle = bundlePath.flatMap(Bundle.init(url:)) {\n"
        output += "                return bundle\n"
        output += "            }\n"
        output += "        }\n"
        output += "\n"
        output += "        // Fallback to the bundle containing this code (works for Bazel builds)\n"
        output += "        return Bundle(for: BundleFinder.self)\n"
        output += "        #endif\n"
        output += "    }()\n"
        output += "}\n"
        return output
    }

    private static func emitFontResourceStruct(configuration: Configuration) -> String {
        let access = configuration.access
        let forceUnwrap = configuration.forceUnwrap
        var output = "\n"
        output += "    // MARK: - Font Resource\n\n"
        output += "    \(access)struct FontResource: Sendable, Hashable {\n"
        output += "        \(access)let fontName: String\n"
        output += "        \(access)let bundle: Bundle\n"

        // UIKit accessor with optional Dynamic Type scaling
        output += "\n"
        output += "        #if canImport(UIKit)\n"
        if forceUnwrap {
            output += "        \(access)func uiFont(size: CGFloat, relativeTo textStyle: UIFont.TextStyle? = nil) -> UIFont {\n"
            output += "            let font = UIFont(name: fontName, size: size)!\n"
            output += "            guard let textStyle else { return font }\n"
            output += "            return UIFontMetrics(forTextStyle: textStyle).scaledFont(for: font)\n"
            output += "        }\n"
        } else {
            output += "        \(access)func uiFont(size: CGFloat, relativeTo textStyle: UIFont.TextStyle? = nil) -> UIFont? {\n"
            output += "            guard let font = UIFont(name: fontName, size: size) else { return nil }\n"
            output += "            guard let textStyle else { return font }\n"
            output += "            return UIFontMetrics(forTextStyle: textStyle).scaledFont(for: font)\n"
            output += "        }\n"
        }
        output += "        #endif\n"

        // AppKit accessor (no Dynamic Type on macOS)
        output += "\n"
        output += "        #if canImport(AppKit) && !targetEnvironment(macCatalyst)\n"
        if forceUnwrap {
            output += "        \(access)func nsFont(size: CGFloat) -> NSFont {\n"
            output += "            NSFont(name: fontName, size: size)!\n"
        } else {
            output += "        \(access)func nsFont(size: CGFloat) -> NSFont? {\n"
            output += "            NSFont(name: fontName, size: size)\n"
        }
        output += "        }\n"
        output += "        #endif\n"

        // SwiftUI accessor with optional Dynamic Type scaling
        output += "\n"
        output += "        #if canImport(SwiftUI)\n"
        output += "        \(access)func font(size: CGFloat, relativeTo textStyle: Font.TextStyle? = nil) -> Font {\n"
        output += "            if let textStyle {\n"
        output += "                return Font.custom(fontName, size: size, relativeTo: textStyle)\n"
        output += "            }\n"
        output += "            return Font.custom(fontName, size: size)\n"
        output += "        }\n"
        output += "        #endif\n"

        output += "    }\n"
        return output
    }

    private static func emitImageResourceStruct(configuration: Configuration) -> String {
        let access = configuration.access
        let forceUnwrap = configuration.forceUnwrap
        var output = "\n"
        output += "    // MARK: - Image Resource\n\n"
        output += "    \(access)struct ImageResource: Sendable, Hashable {\n"
        output += "        \(access)let name: String\n"
        output += "        \(access)let bundle: Bundle\n"

        // UIKit accessor
        output += "\n"
        output += "        #if canImport(UIKit)\n"
        if forceUnwrap {
            output += "        \(access)var uiImage: UIImage {\n"
            output += "            UIImage(named: name, in: bundle, with: nil)!\n"
        } else {
            output += "        \(access)var uiImage: UIImage? {\n"
            output += "            UIImage(named: name, in: bundle, with: nil)\n"
        }
        output += "        }\n"
        output += "        #endif\n"

        // AppKit accessor
        output += "\n"
        output += "        #if canImport(AppKit) && !targetEnvironment(macCatalyst)\n"
        if forceUnwrap {
            output += "        \(access)var nsImage: NSImage {\n"
            output += "            bundle.image(forResource: name)!\n"
        } else {
            output += "        \(access)var nsImage: NSImage? {\n"
            output += "            bundle.image(forResource: name)\n"
        }
        output += "        }\n"
        output += "        #endif\n"

        // SwiftUI accessor
        output += "\n"
        output += "        #if canImport(SwiftUI)\n"
        output += "        \(access)var image: Image {\n"
        output += "            Image(name, bundle: bundle)\n"
        output += "        }\n"
        output += "        #endif\n"

        output += "    }\n"
        return output
    }

    private static func emitColorResourceStruct(configuration: Configuration) -> String {
        let access = configuration.access
        let forceUnwrap = configuration.forceUnwrap
        var output = "\n"
        output += "    // MARK: - Color Resource\n\n"
        output += "    \(access)struct ColorResource: Sendable, Hashable {\n"
        output += "        \(access)let name: String\n"
        output += "        \(access)let bundle: Bundle\n"

        // UIKit accessor
        output += "\n"
        output += "        #if canImport(UIKit)\n"
        if forceUnwrap {
            output += "        \(access)var uiColor: UIColor {\n"
            output += "            UIColor(named: name, in: bundle, compatibleWith: nil)!\n"
        } else {
            output += "        \(access)var uiColor: UIColor? {\n"
            output += "            UIColor(named: name, in: bundle, compatibleWith: nil)\n"
        }
        output += "        }\n"
        output += "        #endif\n"

        // AppKit accessor
        output += "\n"
        output += "        #if canImport(AppKit) && !targetEnvironment(macCatalyst)\n"
        if forceUnwrap {
            output += "        \(access)var nsColor: NSColor {\n"
            output += "            NSColor(named: name, bundle: bundle)!\n"
        } else {
            output += "        \(access)var nsColor: NSColor? {\n"
            output += "            NSColor(named: name, bundle: bundle)\n"
        }
        output += "        }\n"
        output += "        #endif\n"

        // SwiftUI accessor
        output += "\n"
        output += "        #if canImport(SwiftUI)\n"
        output += "        \(access)var color: Color {\n"
        output += "            Color(name, bundle: bundle)\n"
        output += "        }\n"
        output += "        #endif\n"

        output += "    }\n"
        return output
    }

    private static func emitFileResourceStruct(configuration: Configuration) -> String {
        let access = configuration.access
        let forceUnwrap = configuration.forceUnwrap
        var output = "\n"
        output += "    // MARK: - File Resource\n\n"
        output += "    \(access)struct FileResource: Sendable, Hashable {\n"
        output += "        \(access)let name: String\n"
        output += "        \(access)let fileExtension: String\n"
        output += "        \(access)let bundle: Bundle\n\n"
        if forceUnwrap {
            output += "        \(access)var url: URL {\n"
            output += "            bundle.url(forResource: name, withExtension: fileExtension)!\n"
            output += "        }\n\n"
            output += "        \(access)var data: Data {\n"
            output += "            try! Data(contentsOf: url)\n"
            output += "        }\n"
        } else {
            output += "        \(access)var url: URL? {\n"
            output += "            bundle.url(forResource: name, withExtension: fileExtension)\n"
            output += "        }\n\n"
            output += "        \(access)var data: Data? {\n"
            output += "            guard let url = url else { return nil }\n"
            output += "            return try? Data(contentsOf: url)\n"
            output += "        }\n"
        }
        output += "    }\n"
        return output
    }

    private static func emitFontsEnum(
        fonts: [DiscoveredFont],
        configuration: Configuration
    ) -> String {
        let access = configuration.access
        let bundle = configuration.bundleExpression
        var output = "\n"
        output += "    // MARK: - Fonts\n\n"
        output += "    \(access)enum fonts {\n"

        // Add static registration trigger - fonts are registered when enum is first
        // accessed
        if configuration.registerFonts {
            output += "        private static let _register: Void = { registerFonts() }()\n\n"
        }

        for font in fonts {
            let identifier = NameSanitizer.sanitize(font.postScriptName)
            // Touch _register to ensure fonts are registered before first use
            let registerTouch = configuration.registerFonts ? "_ = _register; " : ""
            output += "        \(access)static var \(identifier): FontResource { \(registerTouch)return FontResource(fontName: \"\(font.postScriptName)\", bundle: \(bundle)) }\n"
        }

        output += "    }\n"
        return output
    }

    private static func emitImagesEnum(
        images: [DiscoveredImage],
        configuration: Configuration
    ) -> String {
        let access = configuration.access
        let bundle = configuration.bundleExpression
        var output = "\n"
        output += "    // MARK: - Images\n\n"
        output += "    \(access)enum images {\n"

        for image in images {
            let identifier = NameSanitizer.sanitize(image.name)
            output += "        \(access)static let \(identifier) = ImageResource(name: \"\(image.name)\", bundle: \(bundle))\n"
        }

        output += "    }\n"
        return output
    }

    private static func emitColorsEnum(
        colors: [DiscoveredColor],
        configuration: Configuration
    ) -> String {
        let access = configuration.access
        let bundle = configuration.bundleExpression
        var output = "\n"
        output += "    // MARK: - Colors\n\n"
        output += "    \(access)enum colors {\n"

        for color in colors {
            let identifier = NameSanitizer.sanitize(color.name)
            output += "        \(access)static let \(identifier) = ColorResource(name: \"\(color.name)\", bundle: \(bundle))\n"
        }

        output += "    }\n"
        return output
    }

    private static func emitFilesEnum(
        files: [DiscoveredResource],
        configuration: Configuration
    ) -> String {
        let access = configuration.access
        let bundle = configuration.bundleExpression
        var output = "\n"
        output += "    // MARK: - Files\n\n"
        output += "    \(access)enum files {\n"

        for file in files {
            let identifier = NameSanitizer.sanitize(file.name)
            output += "        \(access)static let \(identifier) = FileResource(name: \"\(file.name)\", fileExtension: \"\(file.extension)\", bundle: \(bundle))\n"
        }

        output += "    }\n"
        return output
    }

    private static func emitRegisterFonts(
        fonts: [DiscoveredFont],
        configuration: Configuration
    ) -> String {
        let access = configuration.access
        let bundle = configuration.bundleExpression
        var output = "\n"
        output += "    // MARK: - Font Registration\n\n"
        output += "    \(access)static func registerFonts() {\n"
        output += "        #if canImport(CoreText)\n"
        output += "        let fontFiles: [(name: String, ext: String)] = [\n"

        // Use unique file names (not PostScript names) for registration
        var seenFiles = Set<String>()
        for font in fonts {
            let key = "\(font.fileName).\(font.fileExtension)"
            if seenFiles.contains(key) {
                continue
            }
            seenFiles.insert(key)
            output += "            (\"\(font.fileName)\", \"\(font.fileExtension)\"),\n"
        }

        output += "        ]\n"
        output += "        for font in fontFiles {\n"
        output += "            guard let url = \(bundle).url(forResource: font.name, withExtension: font.ext) else { continue }\n"
        output += "            CTFontManagerRegisterFontsForURL(url as CFURL, .process, nil)\n"
        output += "        }\n"
        output += "        #endif\n"
        output += "    }\n"
        return output
    }

    // MARK: - Strings Emission

    private static func emitStringsNamespace(
        strings: [String: [DiscoveredString]],
        configuration: Configuration
    ) -> String {
        let access = configuration.access
        var output = "\n"
        output += "    // MARK: - Strings\n\n"
        output += "    \(access)enum strings {\n"

        // Sort table names for deterministic output
        let sortedTables = strings.keys.sorted()

        for tableName in sortedTables {
            guard let tableStrings = strings[tableName] else {
                continue
            }

            output += emitStringTableEnum(
                tableName: tableName,
                strings: tableStrings,
                configuration: configuration
            )
        }

        output += "    }\n"
        return output
    }

    private static func emitStringTableEnum(
        tableName: String,
        strings: [DiscoveredString],
        configuration: Configuration
    ) -> String {
        let access = configuration.access
        let bundle = configuration.bundleExpression
        let tableIdentifier = NameSanitizer.sanitize(tableName)

        var output = "\n"
        output += "        \(access)enum \(tableIdentifier) {\n"

        // Sort strings by their generated identifier for deterministic output
        let sortedStrings = strings.sorted { string1, string2 in
            let id1 = StringIdentifierGenerator.generateIdentifier(for: string1)
            let id2 = StringIdentifierGenerator.generateIdentifier(for: string2)
            return id1 < id2
        }

        for string in sortedStrings {
            output += emitStringAccessor(
                string: string,
                bundle: bundle,
                configuration: configuration
            )
        }

        output += "        }\n"
        return output
    }

    private static func emitStringAccessor(
        string: DiscoveredString,
        bundle: String,
        configuration: Configuration
    ) -> String {
        let access = configuration.access
        let identifier = StringIdentifierGenerator.generateIdentifier(for: string)
        let escapedKey = escapeStringLiteral(string.key)
        let escapedDefault = escapeStringLiteral(string.defaultValue)
        let tableName = string.tableName

        var output = ""

        // Add doc comment
        if let comment = string.comment, !comment.isEmpty {
            output += "            /// \(comment)\n"
        } else {
            // Use default value as doc comment (truncated if long)
            let truncated = string.defaultValue.count > 60
                ? String(string.defaultValue.prefix(57)) + "..."
                : string.defaultValue
            output += "            /// \(escapeDocComment(truncated))\n"
        }

        if string.requiresFunction {
            // Generate function for strings with arguments
            output += emitStringFunction(
                string: string,
                identifier: identifier,
                escapedKey: escapedKey,
                escapedDefault: escapedDefault,
                tableName: tableName,
                bundle: bundle,
                access: access
            )
        } else {
            // Generate computed property for simple strings
            output += "            \(access)static var \(identifier): String {\n"
            output += "                \(bundle).localizedString(forKey: \"\(escapedKey)\", value: \"\(escapedDefault)\", table: \"\(tableName)\")\n"
            output += "            }\n"
        }

        return output
    }

    private static func emitStringFunction(
        string: DiscoveredString,
        identifier: String,
        escapedKey: String,
        escapedDefault: String,
        tableName: String,
        bundle: String,
        access: String
    ) -> String {
        let labels = StringIdentifierGenerator.generateParameterLabels(for: string)

        // Build parameter list
        var params = [String]()
        for (index, arg) in string.arguments.enumerated() {
            let label = labels[index]
            let type = arg.specifier.swiftType
            params.append("_ \(label): \(type)")
        }
        let paramList = params.joined(separator: ", ")

        // Build argument list for String(format:)
        let argList = labels.joined(separator: ", ")

        var output = ""
        output += "            \(access)static func \(identifier)(\(paramList)) -> String {\n"
        output += "                String(format: \(bundle).localizedString(forKey: \"\(escapedKey)\", value: \"\(escapedDefault)\", table: \"\(tableName)\"), \(argList))\n"
        output += "            }\n"

        return output
    }

    /// Escapes a string for use in a Swift string literal.
    private static func escapeStringLiteral(_ string: String) -> String {
        var result = string
        result = result.replacingOccurrences(of: "\\", with: "\\\\")
        result = result.replacingOccurrences(of: "\"", with: "\\\"")
        result = result.replacingOccurrences(of: "\n", with: "\\n")
        result = result.replacingOccurrences(of: "\r", with: "\\r")
        result = result.replacingOccurrences(of: "\t", with: "\\t")
        return result
    }

    /// Escapes a string for use in a documentation comment.
    private static func escapeDocComment(_ string: String) -> String {
        var result = string
        result = result.replacingOccurrences(of: "\n", with: " ")
        result = result.replacingOccurrences(of: "\r", with: "")
        return result
    }
}
