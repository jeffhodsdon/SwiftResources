// Copyright 2025 Jeff Hodsdon
// SPDX-License-Identifier: Apache-2.0

import Foundation

/// Generates Swift source code for type-safe resource access.
enum SwiftEmitter {
    struct Configuration {
        let moduleName: String
        let accessLevel: String
        let bundleOverride: String? // nil = use BundleFinder
        let registerFonts: Bool

        var access: String {
            accessLevel == "public" ? "public " : ""
        }

        var bundleExpression: String {
            guard let override = bundleOverride else {
                return "bundle"
            }
            // Expand shorthand .module to Bundle.module for proper type inference
            if override == ".module" {
                return "Bundle.module"
            }
            return override
        }
    }

    /// Generates Swift source code for the given resources.
    static func emit(
        fonts: [DiscoveredFont],
        images: [DiscoveredResource],
        files: [DiscoveredResource],
        configuration: Configuration
    ) -> String {
        var output = ""
        let access = configuration.access
        let useBundleFinder = configuration.bundleOverride == nil

        // Header
        output += "// \(configuration.moduleName).swift\n"
        output += "// Generated by SwiftResources â€” do not edit\n\n"

        // Imports
        output += emitImports()

        // BundleFinder (if needed)
        if useBundleFinder {
            output += "\nprivate class BundleFinder {}\n"
        }

        // Main enum
        output += "\n\(access)enum \(configuration.moduleName) {\n"

        // Bundle property
        if useBundleFinder {
            output += "    private static let bundle = Bundle(for: BundleFinder.self)\n"
        }

        // Resource type structs
        if !fonts.isEmpty {
            output += emitFontResourceStruct(configuration: configuration)
        }
        if !images.isEmpty {
            output += emitImageResourceStruct(configuration: configuration)
        }
        if !files.isEmpty {
            output += emitFileResourceStruct(configuration: configuration)
        }

        // Resource namespaces
        if !fonts.isEmpty {
            output += emitFontsEnum(fonts: fonts, configuration: configuration)
        }
        if !images.isEmpty {
            output += emitImagesEnum(images: images, configuration: configuration)
        }
        if !files.isEmpty {
            output += emitFilesEnum(files: files, configuration: configuration)
        }

        // Font registration
        if configuration.registerFonts && !fonts.isEmpty {
            output += emitRegisterFonts(fonts: fonts, configuration: configuration)
        }

        output += "}\n"

        return output
    }

    // MARK: - Private Helpers

    private static func emitImports() -> String {
        var output = ""
        output += "import Foundation\n"
        output += "#if canImport(UIKit)\n"
        output += "import UIKit\n"
        output += "#endif\n"
        output += "#if canImport(AppKit)\n"
        output += "import AppKit\n"
        output += "#endif\n"
        output += "#if canImport(SwiftUI)\n"
        output += "import SwiftUI\n"
        output += "#endif\n"
        return output
    }

    private static func emitFontResourceStruct(configuration: Configuration) -> String {
        let access = configuration.access
        var output = "\n"
        output += "    // MARK: - Font Resource\n\n"
        output += "    \(access)struct FontResource: Sendable, Hashable {\n"
        output += "        \(access)let fontName: String\n"
        output += "        \(access)let bundle: Bundle\n"

        // UIKit accessor
        output += "\n"
        output += "        #if canImport(UIKit)\n"
        output += "        \(access)func uiFont(size: CGFloat) -> UIFont? {\n"
        output += "            UIFont(name: fontName, size: size)\n"
        output += "        }\n"
        output += "        #endif\n"

        // AppKit accessor
        output += "\n"
        output += "        #if canImport(AppKit) && !targetEnvironment(macCatalyst)\n"
        output += "        \(access)func nsFont(size: CGFloat) -> NSFont? {\n"
        output += "            NSFont(name: fontName, size: size)\n"
        output += "        }\n"
        output += "        #endif\n"

        // SwiftUI accessor
        output += "\n"
        output += "        #if canImport(SwiftUI)\n"
        output += "        \(access)func font(size: CGFloat) -> Font {\n"
        output += "            Font.custom(fontName, size: size)\n"
        output += "        }\n"
        output += "        #endif\n"

        output += "    }\n"
        return output
    }

    private static func emitImageResourceStruct(configuration: Configuration) -> String {
        let access = configuration.access
        var output = "\n"
        output += "    // MARK: - Image Resource\n\n"
        output += "    \(access)struct ImageResource: Sendable, Hashable {\n"
        output += "        \(access)let name: String\n"
        output += "        \(access)let bundle: Bundle\n"

        // UIKit accessor
        output += "\n"
        output += "        #if canImport(UIKit)\n"
        output += "        \(access)var uiImage: UIImage? {\n"
        output += "            UIImage(named: name, in: bundle, with: nil)\n"
        output += "        }\n"
        output += "        #endif\n"

        // AppKit accessor
        output += "\n"
        output += "        #if canImport(AppKit) && !targetEnvironment(macCatalyst)\n"
        output += "        \(access)var nsImage: NSImage? {\n"
        output += "            bundle.image(forResource: name)\n"
        output += "        }\n"
        output += "        #endif\n"

        // SwiftUI accessor
        output += "\n"
        output += "        #if canImport(SwiftUI)\n"
        output += "        \(access)var image: Image {\n"
        output += "            Image(name, bundle: bundle)\n"
        output += "        }\n"
        output += "        #endif\n"

        output += "    }\n"
        return output
    }

    private static func emitFileResourceStruct(configuration: Configuration) -> String {
        let access = configuration.access
        var output = "\n"
        output += "    // MARK: - File Resource\n\n"
        output += "    \(access)struct FileResource: Sendable, Hashable {\n"
        output += "        \(access)let name: String\n"
        output += "        \(access)let fileExtension: String\n"
        output += "        \(access)let bundle: Bundle\n\n"
        output += "        \(access)var url: URL? {\n"
        output += "            bundle.url(forResource: name, withExtension: fileExtension)\n"
        output += "        }\n\n"
        output += "        \(access)var data: Data? {\n"
        output += "            guard let url = url else { return nil }\n"
        output += "            return try? Data(contentsOf: url)\n"
        output += "        }\n"
        output += "    }\n"
        return output
    }

    private static func emitFontsEnum(
        fonts: [DiscoveredFont],
        configuration: Configuration
    ) -> String {
        let access = configuration.access
        let bundle = configuration.bundleExpression
        var output = "\n"
        output += "    // MARK: - Fonts\n\n"
        output += "    \(access)enum fonts {\n"

        // Add static registration trigger - fonts are registered when enum is first accessed
        if configuration.registerFonts {
            output += "        private static let _register: Void = { registerFonts() }()\n\n"
        }

        for font in fonts {
            let identifier = NameSanitizer.sanitize(font.postScriptName)
            // Touch _register to ensure fonts are registered before first use
            let registerTouch = configuration.registerFonts ? "_ = _register; " : ""
            output += "        \(access)static var \(identifier): FontResource { \(registerTouch)return FontResource(fontName: \"\(font.postScriptName)\", bundle: \(bundle)) }\n"
        }

        output += "    }\n"
        return output
    }

    private static func emitImagesEnum(
        images: [DiscoveredResource],
        configuration: Configuration
    ) -> String {
        let access = configuration.access
        let bundle = configuration.bundleExpression
        var output = "\n"
        output += "    // MARK: - Images\n\n"
        output += "    \(access)enum images {\n"

        for image in images {
            let identifier = NameSanitizer.sanitize(image.name)
            output += "        \(access)static let \(identifier) = ImageResource(name: \"\(image.name)\", bundle: \(bundle))\n"
        }

        output += "    }\n"
        return output
    }

    private static func emitFilesEnum(
        files: [DiscoveredResource],
        configuration: Configuration
    ) -> String {
        let access = configuration.access
        let bundle = configuration.bundleExpression
        var output = "\n"
        output += "    // MARK: - Files\n\n"
        output += "    \(access)enum files {\n"

        for file in files {
            let identifier = NameSanitizer.sanitize(file.name)
            output += "        \(access)static let \(identifier) = FileResource(name: \"\(file.name)\", fileExtension: \"\(file.extension)\", bundle: \(bundle))\n"
        }

        output += "    }\n"
        return output
    }

    private static func emitRegisterFonts(
        fonts: [DiscoveredFont],
        configuration: Configuration
    ) -> String {
        let access = configuration.access
        let bundle = configuration.bundleExpression
        var output = "\n"
        output += "    // MARK: - Font Registration\n\n"
        output += "    \(access)static func registerFonts() {\n"
        output += "        let fontFiles: [(name: String, ext: String)] = [\n"

        // Use unique file names (not PostScript names) for registration
        var seenFiles = Set<String>()
        for font in fonts {
            let key = "\(font.fileName).\(font.fileExtension)"
            if seenFiles.contains(key) {
                continue
            }
            seenFiles.insert(key)
            output += "            (\"\(font.fileName)\", \"\(font.fileExtension)\"),\n"
        }

        output += "        ]\n"
        output += "        for font in fontFiles {\n"
        output += "            guard let url = \(bundle).url(forResource: font.name, withExtension: font.ext) else { continue }\n"
        output += "            CTFontManagerRegisterFontsForURL(url as CFURL, .process, nil)\n"
        output += "        }\n"
        output += "    }\n"
        return output
    }
}
